apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: task-post-slack
spec:
  inputs:
    params:
      - name: task-pvc
        description: the output pvc
      - name: channel
        description: the Slack channel to send the message to. If not set, all channels integrated to the toolchain will be notified.
        default: ' '
      - name: messageFormat
        description: the format of the message. text(default) or JSON.
        default: text
      - name: messageScript
        description: Shell script that provides messsage content.
        default: ''
      - name: message
        description: the message to send to Slack
        default: 'Tekton Pipeline completed successfully. :heavy_check_mark:\nVisit *<https://api.slack.com/reference/surfaces/formatting|More on Slack message formatting.>*'
  steps:
    - name: post-to-slack
      # tbd: use an image with curl and jq?
      image: ibmcom/pipeline-base-image
      env:
        - name: SLACK_MESSAGE
          value: $(inputs.params.message)
        - name: MESSAGE_FORMAT
          value: $(inputs.params.messageFormat)
      command: ["/bin/bash", "-c"]
      args:
        - |
          set -e -o pipefail
          # check if a channel was passed as parameter
          SLACK_CHANNEL=$(echo $(inputs.params.channel))
          if [ "$SLACK_CHANNEL" ]; then
            echo "Retrieving Slack webhook for $SLACK_CHANNEL channel."
            SLACK_WEBHOOKS=$(cat /cd-config/toolchain.json | jq -r '.services[] | select (.service_id=="slack") | select (.parameters.channel_name=="'"${SLACK_CHANNEL}"'") | .parameters.api_token')          
          else
            echo "No channel specified: posting to each slack channel integrated to the toolchain."
            SLACK_WEBHOOKS=$(cat /cd-config/toolchain.json | jq -r '.services[] | select (.service_id=="slack") | .parameters.api_token')
          fi
          if [[ $SLACK_WEBHOOKS == '' ]]; then
              echo "No webhook found for channel $SLACK_CHANNEL."
              echo "Verify that this channel has been integrated to toolchain ${TOOLCHAIN_ID}."
              echo "Toolchain URL: ${API}/devops/toolchains/${TOOLCHAIN_ID}?env_id=ibm:yp:${REGION}"
              echo "Exiting..."
              exit 1
          fi
          # Dynamically set message if messageScript param is set
          printf "#!/bin/sh\n" > /steps/messageScript.sh 
          print "%s " '$(inputs.params.messageScript)' >> /steps/messageScript.sh
          printf "\n" >> /steps/messageScript.sh
          chmod +x /steps/messageScript.sh
          echo "************************************"
          echo "Snippet for dynamic message content:"
          cat /steps/messageScript.sh
          echo "************************************"
          /steps/messageScript.sh 2 >& 1 > /steps/message.content
          if [ -s /steps/message.content ]; then
            echo "Using dynamic message from messageScript."
            cat /steps/message.content
          else 
             echo "${SLACK_MESSAGE}" > /steps/message.content
          fi
          if [[ "${MESSAGE_FORMAT}" == "text" ]]; then
            # format message to a Slack JSON payload
            echo '{"type": "text"}' | jq --rawfile text /steps/message.content '.text=$text' > /steps/payload.json
          else 
            mv /steps/message.content /steps/payload.json
          fi      
          echo "Slack Message payload:"
          cat /steps/payload.json
          echo ""
          for WEBHOOK in $SLACK_WEBHOOKS
            do
             echo "Posting Slack Message using Webhook $WEBHOOK."
            # TODO
            # L'intégration slack définit un webhook mais également potentiellement un channel qui peut etre différent de 
            # celui par défaut dans le webhook. il faut donc spécifier le channel obtenu via la task ou via le toolchain.json
            # si vide, c'est celui par défaut du slack qui sera utilisé
             curl -X POST -H 'Content-type: application/json' -d @/steps/payload.json $WEBHOOK
             # Si erreur il faut faire un exit conditionnel ?
          done
      volumeMounts:
        - mountPath: /steps
          name: steps-volume
        - mountPath: /cd-config
          name: cd-config-volume
  volumes:
    - name: steps-volume
      emptyDir: {}
    - name: cd-config-volume
      configMap:
        name: toolchain
        items:
          - key: toolchain.json
            path: toolchain.json
